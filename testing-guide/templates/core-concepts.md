# 测试核心理念

## 测试的目的

```
测试的目的不是"覆盖代码"，而是"验证行为"。

❌ 错误理解：让每一行代码都被执行过
✅ 正确理解：确保系统按照需求正确工作
```

## 测试质量金字塔

```
┌─────────────────────────────────────────────────────────────┐
│                    测试质量金字塔                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Level 3: 测试有效性（最高标准）                              │
│    - 变异得分 (Mutation Score) ≥ 80%                        │
│    - 需求-测试追溯覆盖 100%                                  │
│    - 测试能捕获真实缺陷                                      │
│                                                             │
│  Level 2: 断言质量（核心要求）                                │
│    - 禁止弱断言                                              │
│    - 每个测试 ≥1 个具体断言                                  │
│    - 测试名称描述预期行为                                     │
│    - 断言验证行为而非实现                                     │
│                                                             │
│  Level 1: 代码覆盖（基础门槛）                                │
│    - 行覆盖率 ≥ 80%                                          │
│    - 分支覆盖率 ≥ 80%                                        │
│    - ⚠️ 这只是必要条件，不是充分条件                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 测试依据来自需求

单元测试的依据**不是代码本身**，而是：

| 优先级 | 依据来源 | 测试类型 | 验证内容 |
|--------|----------|----------|----------|
| 1 | **需求/验收标准** | 功能测试 | 业务规则是否正确 |
| 2 | **接口契约** | 契约测试 | 输入输出是否符合约定 |
| 3 | **边界条件** | 边界测试 | 极端情况是否处理 |
| 4 | **错误场景** | 异常测试 | 错误是否正确处理 |
| 5 | 代码路径 | 覆盖率 | 代码是否被执行 |

### 从需求推导测试

```
需求: "用户密码必须至少8位，包含大小写字母和数字"
  │
  ▼
测试用例推导（不是看代码写测试）:
  ├── [正向] 8位有效密码（含大小写和数字）→ 通过
  ├── [边界] 恰好8位有效密码 → 通过
  ├── [边界] 7位密码 → 拒绝
  ├── [规则] 无大写字母 → 拒绝
  ├── [规则] 无小写字母 → 拒绝
  ├── [规则] 无数字 → 拒绝
  └── [边界] 空密码 → 拒绝
```

### 从接口契约推导测试

```typescript
// 接口契约
interface UserService {
  /**
   * 根据ID获取用户
   * @param id - 用户ID，必须为正整数
   * @returns 用户对象，如果不存在返回 null
   * @throws InvalidIdError - 当 id 不是正整数时
   */
  getUser(id: number): User | null;
}

// 从契约推导的测试
describe('UserService.getUser', () => {
  it('应该返回存在的用户', () => {});           // 正常返回
  it('应该返回 null 当用户不存在时', () => {}); // null 返回
  it('应该抛出 InvalidIdError 当 id <= 0', () => {}); // 异常
  it('应该抛出 InvalidIdError 当 id 不是整数', () => {}); // 异常
});
```

## 覆盖率的局限性

```
场景：100% 代码覆盖率但测试无效

function add(a, b) {
  return a + b;
}

// 100% 覆盖率的无效测试
test('add', () => {
  add(1, 2);  // 没有断言！
});

变异测试结果：
- 变异: return a - b  → 测试通过 → 变异体存活 ❌
- 变异: return a * b  → 测试通过 → 变异体存活 ❌
- 变异: return 0      → 测试通过 → 变异体存活 ❌

变异得分: 0%（覆盖率 100%！）
```

## 变异测试原理

变异测试通过**自动修改代码**来检验测试的有效性。

```
原理:
1. 自动生成代码"变异体"（修改后的代码）
2. 对每个变异体运行测试
3. 如果测试通过 → 测试无效（未能发现bug）
4. 如果测试失败 → 测试有效（成功捕获变异）

变异得分 = 被杀死的变异体 / 总变异体 × 100%
```

### 变异操作类型

| 变异类型 | 原代码 | 变异后 | 检测能力 |
|----------|--------|--------|----------|
| **边界变异** | `a > b` | `a >= b` | 边界条件测试 |
| **操作符变异** | `a + b` | `a - b` | 计算逻辑测试 |
| **常量变异** | `return 0` | `return 1` | 返回值测试 |
| **否定变异** | `if (cond)` | `if (!cond)` | 条件逻辑测试 |
| **删除变异** | `func()` | `// removed` | 副作用测试 |

## 测试代码 Review 检查清单

### 测试有效性
- [ ] 测试是否验证行为而非实现？
- [ ] 每个测试是否有明确的断言？
- [ ] 断言是否足够具体（不是弱断言）？
- [ ] 测试名称是否描述预期行为？

### 测试独立性
- [ ] 测试是否可以独立运行？
- [ ] 测试之间是否有数据依赖？
- [ ] 测试顺序是否影响结果？

### Mock 质量
- [ ] Mock 是否只用于外部依赖？
- [ ] Mock 是否验证了调用参数？
- [ ] 是否避免了过度 Mock？

### 可维护性
- [ ] 测试代码是否遵循 DRY 原则？
- [ ] 测试数据是否使用工厂函数？
- [ ] 测试结构是否清晰（AAA 模式）？
